import asyncio
import subprocess
import os
import json

from helpers.llm import get_mcp_client
from helpers.git import get_latest_commit_message, stage_and_create_commit, get_branch_name, get_full_diff, get_recent_commits, reset_head_by_commits, switch_branch, unstage_all_files

async def get_suggested_commit_message():
    current_dir = os.path.dirname(os.path.abspath(__file__))
    agent_dir = os.path.join(os.path.dirname(current_dir), 'commit-message-agent')
    script_path = os.path.join(agent_dir, 'commit_message_agent.py')
    
    result = subprocess.run(['python', script_path], 
                          capture_output=True, 
                          text=True)
    
    if result.returncode != 0:
        raise Exception(f"Error running commit message agent: {result.stderr}")
    
    return result.stdout.strip()

async def seed_db():
    current_dir = os.path.dirname(os.path.abspath(__file__))
    agent_dir = os.path.join(os.path.dirname(current_dir), 'kanban')
    script_path = os.path.join(agent_dir, 'seed.py')
    
    result = subprocess.run(['python', script_path], 
                          capture_output=True, 
                          text=True)
    
    if result.returncode != 0:
        raise Exception(f"Error seeding db: {result.stderr}")
    
    return result.stdout.strip()

def get_judging_prompt(commit_message="", diff="", branch="", commits=[]):
    prompt = f"""
[Personality]
You are a judge that evaluates commit messages generated by an LLM.
[End of Personality]

[Judging Criteria]
1. The message wording should be clear and concise.
2. The message format should strictly follow the Conventional Commits specification.
3. The message should be strictly relevant to the changes made in the code.
4. The message should be consistent with previous commit messages in the same repository.
5. You are also provided with a Kanban MCP server to fetch details about the ticket. Fetch the details if the branch name contains a ticket ID. But ensure that even after you fetch the details the commit message should only have details relevant to the changes made in the code. If the changes are not relevant to the ticket, do not include the ticket details in the commit message.
[End of Judging Criteria]

[Examples of Good Commit Messages]

feat(api): add support for pagination

    - Enables cursor-based pagination for large datasets
    - Adds `pageToken` and `limit` query params to endpoints

fix(auth): resolve login loop issue
    - Fixes token expiration not redirecting to login
    - Adds unit tests for edge-case logouts

[End of Examples of Good Commit Messages]

[Task]
Given a commit message, determine if it passes the judging criteria.
As input you will be provided the following details:
    1. The commit message to be judged.
    2. The full diff of the changes.
    3. The current branch name.
    4. The last few commit messages for reference.
[End of Task]

[Input]
    [Commit Message Start]
    {commit_message}
    [Commit Message End]

    [Full Diff Start]
    {diff}
    [Full Diff End]

    [Branch Name Start]
    {branch}
    [Branch Name End]

    [Recent Commits Start]
    {(chr(10) * 2).join(commits)}
    [Recent Commits End]
[End of Input]

[Output]
Provide a ruling on the commit message based on the judging criteria in JSON format.
Provided a top level pass: true or false key.
The commit message should pass only if it passes all the judging criteria.

Create another nested key for each criteria with a boolean value indicating if the commit message passes that criterion.
If the commit message does not pass that criteria, suggest improvements in the commit message that will pass that criteria.
Also output the thinking steps very clearly


    [Output Format Examples]
    {{
        "pass": true,
        "criteria": {{
            "clear_and_concise": true,
            "conventional_commits_format": true,
            "relevant_to_changes": true,
            "consistent_with_previous_commits": true,
            "kanban_ticket_details_used_correctly": true
        }}
    }}

    {{
        "pass": false,
        "criteria": {{
            "clear_and_concise": true,
            "conventional_commits_format": false,
            "relevant_to_changes": false,
            "consistent_with_previous_commits": true,
            "kanban_ticket_details_used_correctly": false
        }},
        "improvements": {{
            "conventional_commits_format": "<suggested improvements>",
            "relevant_to_changes": "<suggested improvements>",
            "kanban_ticket_details_used_correctly": "<suggested improvements>"
        }}
    }}
    [End of Output Format Examples]
[End of Output]
"""

    return prompt

async def judge_commit_message(prompt, mcp_agent):
    return await mcp_agent.run(
        prompt,
        max_steps=10,
    )

async def run_test_cases(branch_name):
    mcp_agent = get_mcp_client()

    switch_branch(branch_name)
    original_commit_message  = get_latest_commit_message()
    reset_head_by_commits(1)
    unstage_all_files()
    
    await seed_db()
    commit_message = await get_suggested_commit_message()
    print(commit_message)

    diff = get_full_diff()
    branch = get_branch_name()
    commits = get_recent_commits()
    
    prompt = get_judging_prompt(commit_message, diff, branch, commits)
    ruling = await judge_commit_message(prompt, mcp_agent)

    stage_and_create_commit(original_commit_message)
    switch_branch('main')

    return ruling

async def main(test_cases):
    results = []
    for branch_name in test_cases:
        raw_output = await run_test_cases(branch_name)
        test_case = json.loads(raw_output)
        results.append(test_case.get('pass', {}))
    
    return results

if __name__ == "__main__":
    test_cases = [
        'feat/311',
        'feat/317',
        'fix/359',
        'feat/452'
    ]

    ruling = asyncio.run(main(test_cases))
    print("\nJudge ruling:")
    print(ruling)
