import subprocess
import os

from helpers.llm import get_mcp_client
from helpers.git import get_latest_commit_message, stage_and_create_commit, get_branch_name, get_full_diff, get_recent_commits, reset_head_by_commits, switch_branch, unstage_all_files

async def get_suggested_commit_message():
    current_dir = os.path.dirname(os.path.abspath(__file__))
    agent_dir = os.path.join(os.path.dirname(current_dir), 'commit-message-agent')
    script_path = os.path.join(agent_dir, 'commit_message_agent.py')
    
    result = subprocess.run(['python', script_path], 
                          capture_output=True, 
                          text=True)
    
    if result.returncode != 0:
        raise Exception(f"Error running commit message agent: {result.stderr}")
    
    return result.stdout.strip()

async def seed_db():
    current_dir = os.path.dirname(os.path.abspath(__file__))
    agent_dir = os.path.join(os.path.dirname(current_dir), 'kanban')
    script_path = os.path.join(agent_dir, 'seed.py')
    
    result = subprocess.run(['python', script_path], 
                          capture_output=True, 
                          text=True)
    
    if result.returncode != 0:
        raise Exception(f"Error seeding db: {result.stderr}")
    
    return result.stdout.strip()

def get_judging_prompt(commit_message="", diff="", branch="", commits=[]):
    prompt = f"""
[Personality]
You are a judge that evaluates commit messages generated by an LLM.
[End of Personality]

[Judging Criteria]
1. The message wording should be clear and concise. It should use verbs like Add instead of Adds or Adding, Update instead of Updates, updating etc.
2. Strictly follow the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification.
3. The message should be strictly relevant to the changes made in the code.
4. The message should be consistent with previous commit messages in the same repository. Do not focus on the exact wording, but rather the structure of the previous commits.
5. Use the Kanban MCP server to fetch ticket details if the branch name includes a ticket ID.
   - Include ticket information in the commit message if it directly relates to the code changes.
   - If the ticket contains broader context but is unrelated to the code change, do not include that information.
   - The commit message need not directly indicate that it is related to a ticket, but if the branch name includes a ticket ID, it should be used to provide context for the commit message.
   - Do not expect the commit message to include the ticket ID or title. The message may contain relevant details from the ticket, but it should not be explicitly stated that it is related to a ticket.
   - The commit message should just contain the overall jist of the ticket. Exact words don't need to be used.

[Branch name including Ticket ID Examples]
    - feat-265
    Here the ticket ID is 265, and the branch name is `feat-265`.

    - chore/999
    Here the ticket ID is 999, and the branch name is `chore/999`.

    - log_analyzer-1310
    Here the ticket ID is 1310, and the branch name is `log_analyzer-1310`.
[Branch name including Ticket ID Examples ends]

[End of Judging Criteria]

[Examples of Good Commit Messages]

feat(api): add support for pagination

    - Enables cursor-based pagination for large datasets
    - Adds `pageToken` and `limit` query params to endpoints

fix(auth): resolve login loop issue
    - Fixes token expiration not redirecting to login
    - Adds unit tests for edge-case logouts

[End of Examples of Good Commit Messages]

[Task]
Given a commit message, determine if it passes the judging criteria.
As input you will be provided the following details:
    1. The commit message to be judged.
    2. The full diff of the changes.
    3. The current branch name.
    4. The last few commit messages for reference.
[End of Task]

[Input]
    [Commit Message Start]
    {commit_message}
    [Commit Message End]

    [Full Diff Start]
    {diff}
    [Full Diff End]

    [Branch Name Start]
    {branch}
    [Branch Name End]

    [Recent Commits Start]
    {(chr(10) * 2).join(commits)}
    [Recent Commits End]
[End of Input]

[Output]
Provide a ruling on the commit message based on the judging criteria in JSON format.
Provided a top level pass: true or false key.
The commit message should pass only if it passes all the judging criteria.
Strictly follow the judging criteria and it is illegal to deviate from them.

Create another nested key for each criteria with a boolean value indicating if the commit message passes that criterion.
If the commit message does not pass that criteria, suggest improvements in the commit message that will pass that criteria.


    [Output Format Examples]
    {{
        "pass": true,
        "criteria": {{
            "clear_and_concise": true,
            "conventional_commits_format": true,
            "relevant_to_changes": true,
            "consistent_with_previous_commits": true,
            "kanban_ticket_details_used_correctly": true
        }}
    }}

    {{
        "pass": false,
        "criteria": {{
            "clear_and_concise": true,
            "conventional_commits_format": false,
            "relevant_to_changes": false,
            "consistent_with_previous_commits": true,
            "kanban_ticket_details_used_correctly": false
        }},
        "improvements": {{
            "conventional_commits_format": "<suggested improvements>",
            "relevant_to_changes": "<suggested improvements>",
            "kanban_ticket_details_used_correctly": "<suggested improvements>"
        }}
    }}
    [End of Output Format Examples]
[End of Output]

Improvements must be very specific and completely unambiguous.
Ensure that the improvements you mention are factually correct. Check the commit message against the judging criteria before suggesting improvements.
"""
    return prompt

async def judge_commit_message(prompt, mcp_agent):
    return await mcp_agent.run(
        prompt,
        max_steps=10,
    )

async def run_test_case(branch_name):
    mcp_agent = get_mcp_client()

    switch_branch(branch_name)
    original_commit_message = get_latest_commit_message()
    reset_head_by_commits(1)
    unstage_all_files()
    
    await seed_db()
    commit_message = await get_suggested_commit_message()

    diff = get_full_diff()
    branch = get_branch_name()
    commits = get_recent_commits()
    
    prompt = get_judging_prompt(commit_message, diff, branch, commits)
    ruling = await judge_commit_message(prompt, mcp_agent)

    stage_and_create_commit(original_commit_message)
    switch_branch('main')

    return {
        'ruling': ruling,
        'commit_message': commit_message
    }
